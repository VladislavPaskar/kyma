// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	"github.com/nats-io/nats.go"
	mock "github.com/stretchr/testify/mock"
)

// JetStreamManager is an autogenerated mock type for the JetStreamManager type
type JetStreamManager struct {
	mock.Mock
}

// AccountInfo provides a mock function with given fields: opts
func (_m *JetStreamManager) AccountInfo(opts ...nats.JSOpt) (*nats.AccountInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.AccountInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) *nats.AccountInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.AccountInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...nats.JSOpt) error); ok {
		r1 = rf(opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamManager) AddConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamManager) AddStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConsumerInfo provides a mock function with given fields: stream, name, opts
func (_m *JetStreamManager) ConsumerInfo(stream string, name string, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, name, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, name, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConsumerNames provides a mock function with given fields: stream, opts
func (_m *JetStreamManager) ConsumerNames(stream string, opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan string); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// ConsumersInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamManager) ConsumersInfo(stream string, opts ...nats.JSOpt) <-chan *nats.ConsumerInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) <-chan *nats.ConsumerInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.ConsumerInfo)
		}
	}

	return r0
}

// DeleteConsumer provides a mock function with given fields: stream, consumer, opts
func (_m *JetStreamManager) DeleteConsumer(stream string, consumer string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, consumer)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) error); ok {
		r0 = rf(stream, consumer, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamManager) DeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteStream provides a mock function with given fields: name, opts
func (_m *JetStreamManager) DeleteStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetLastMsg provides a mock function with given fields: name, subject, opts
func (_m *JetStreamManager) GetLastMsg(name string, subject string, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, subject)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	if rf, ok := ret.Get(0).(func(string, string, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, subject, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, ...nats.JSOpt) error); ok {
		r1 = rf(name, subject, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamManager) GetMsg(name string, seq uint64, opts ...nats.JSOpt) (*nats.RawStreamMsg, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.RawStreamMsg
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) *nats.RawStreamMsg); ok {
		r0 = rf(name, seq, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.RawStreamMsg)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, uint64, ...nats.JSOpt) error); ok {
		r1 = rf(name, seq, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PurgeStream provides a mock function with given fields: name, opts
func (_m *JetStreamManager) PurgeStream(name string, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) error); ok {
		r0 = rf(name, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SecureDeleteMsg provides a mock function with given fields: name, seq, opts
func (_m *JetStreamManager) SecureDeleteMsg(name string, seq uint64, opts ...nats.JSOpt) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, name, seq)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, uint64, ...nats.JSOpt) error); ok {
		r0 = rf(name, seq, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StreamInfo provides a mock function with given fields: stream, opts
func (_m *JetStreamManager) StreamInfo(stream string, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(string, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(stream, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...nats.JSOpt) error); ok {
		r1 = rf(stream, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StreamNames provides a mock function with given fields: opts
func (_m *JetStreamManager) StreamNames(opts ...nats.JSOpt) <-chan string {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan string
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan string); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan string)
		}
	}

	return r0
}

// StreamsInfo provides a mock function with given fields: opts
func (_m *JetStreamManager) StreamsInfo(opts ...nats.JSOpt) <-chan *nats.StreamInfo {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 <-chan *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(...nats.JSOpt) <-chan *nats.StreamInfo); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *nats.StreamInfo)
		}
	}

	return r0
}

// UpdateConsumer provides a mock function with given fields: stream, cfg, opts
func (_m *JetStreamManager) UpdateConsumer(stream string, cfg *nats.ConsumerConfig, opts ...nats.JSOpt) (*nats.ConsumerInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.ConsumerInfo
	if rf, ok := ret.Get(0).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) *nats.ConsumerInfo); ok {
		r0 = rf(stream, cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.ConsumerInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *nats.ConsumerConfig, ...nats.JSOpt) error); ok {
		r1 = rf(stream, cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateStream provides a mock function with given fields: cfg, opts
func (_m *JetStreamManager) UpdateStream(cfg *nats.StreamConfig, opts ...nats.JSOpt) (*nats.StreamInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, cfg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *nats.StreamInfo
	if rf, ok := ret.Get(0).(func(*nats.StreamConfig, ...nats.JSOpt) *nats.StreamInfo); ok {
		r0 = rf(cfg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.StreamInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*nats.StreamConfig, ...nats.JSOpt) error); ok {
		r1 = rf(cfg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewJetStreamManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewJetStreamManager creates a new instance of JetStreamManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewJetStreamManager(t mockConstructorTestingTNewJetStreamManager) *JetStreamManager {
	mock := &JetStreamManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
